/****************************************************************************
 *
 * Function:	keyword_find
 *
 * Description:	Maps encrypted keyword to real keyword
 *		        name and machine name as keywords and
 *		        the time stamp as the seed for the encryption.
 *		        Builds the doubly encrypted keyword using the
 *		        receiving user's Email address as the encryption
 *		        key. Sends the encrypted keyword to the receiving user.
 *
 ***************************************************************************/

#include <stdio.h>
#include <string.h>

#include "bad_trans_keys.h"
#include "close_down.h"
#include "company.h"
#include "global_defines.h"
#include "global_server_errs.h"
#include "global_server_params.h"
#include "global_server_prototypes.h"
#include "keyword.h"
#include "trans_server_defines.h"
#include "trans_server_errs.h"
#include "reg_globals.h"
#include "trans_server_globals.h"
#include "trans_server_paths.h"
#include "trans_lib_prototypes.h"
#include "rtn.h"
#include "strcpy.h"
#include "user_params.h"
#include "ldapfsl.h"
#include "global_debug.h"

/*!
 * \brief keyword_disk_lookup()
 * \param file_keyword
 * \return SUCESS if that file_keyword is/was stored on that server
 */
int keyword_disk_lookup(char *file_keyword)
{
    char file[FILE_SIZE];
    int ret = SUCCESS;
    sprintf(file, "global_data/%s", file_keyword);
    if (access(file,0) != 0)
    {
        // check if it was there but has been deleted
        sprintf(file, "history_data/%s.history", file_keyword);
        if (access(file,0) != 0)
        {
            ret = FAILURE;
        }
    }
    return ret;
}


/*  Parameters:
 *      char *new_keyword,	New keyword generated by this function
 *      char *key, Different string used for each transaction
 *      int index Helps make the key more random
 */
void keyword_create(char *new_keyword, char *key, int index)
{
    extern char keyword_extension[];
    char upd_string[24];
    unsigned long tmp_string;
    int len;
    int i;
    int iran;
    int j;
    int iseed;
    float get_random();

    DBG();

    iseed = (tr.upd_time-773700000)*key[0]*tr.pid*index;

    /* Encrypt the data one character at a time.  */
    /* This is done by exclusive or'ing a random  */
    /* number with each character and             */
    /* outputting the resultant character         */
    for ( i = 0; i < 4; ++i)
    {
        iran = 26.0*get_random(&iseed);
        j = 26.0*(iran^key[i]);
        new_keyword[i] = iran+97;
    }

    /* Verify this is not a bad key */
    keyword_verify(new_keyword);

    /* Add a random number */
    /* The random number is the last 4 characters of the time stamp */
    tmp_string = iran*tr.upd_time * tr.upd_time+index;
    sprintf(upd_string, "%lu", tmp_string);

    len = strlen(upd_string);
    if (len < 4)
    {
        len = 4;
        strcpy(upd_string, "6925");
    }

    strcpy2(new_keyword+4, upd_string+len-4, keyword_extension);
#if defined(DEBUG)  && defined(FORCE_SECURE_KEYWORD)
    {
        static int counter = 0;
        if (counter++ == 1)
        {
            strcpy(new_keyword, FORCE_SECURE_KEYWORD);
        }
    }
#endif
    DBG("new_keyword=%s", new_keyword);
} /* End keyword_create */


/* See if keyword is for this site
 * Send to different server if not meant for this site
 * If is secure keyword, translate to file keyword
 * Parameters:
 *    char *secure_key,	Encrypted key to be deccrypted
 *    char *file_key, Decrypted key
 **/
int keyword_find(char *secure_key, char *file_key)
{
    extern char keyword_extension[];
    extern char secure_keyword_extension[];
    extern char program_name[];
    int look_in_file     = 0;
    int look_in_database = 0;
    int ret = FAILURE; // it is not a secure keyword

    DBG();

    /* Make sure  this is a 9 character keyword */
    secure_key[9] = '\0';

	/* If this is a secure keyword for this site, look it up */
    if (isupper(secure_key[8]))
    {
        DBG("keyword_database_lookup(secure_key='%s', file_key='%s')", secure_key, file_key);
        look_in_database = keyword_database_lookup(secure_key, file_key);
        if (look_in_database == NO_ENCRYPTION_KEY)
        {
            DBG("keyword_lookup(secure_key='%s', file_key='%s')", secure_key, file_key);
            if ((look_in_file = keyword_lookup(secure_key, file_key)) == NO_ENCRYPTION_KEY)
            {
                sprintf(rtn.msg, no_encryption_key, secure_key, program_name);
                shut_down(rtn.msg, NO_ENCRYPTION_KEY);
            }
        }
        if (look_in_database == ENCRYPTION_AUTH_ERR || look_in_file == ENCRYPTION_AUTH_ERR)
        {
            // rtn.msg already formatted by format_secure_keyword_authorization_error()
            shut_down(rtn.msg, ENCRYPTION_AUTH_ERR);
        }
        // OK
        ret = DBYES;  // it is secure keyword
    }
    else
    {
        ret = DBNO;  // it is a file keyword
    }

    if (ret != FAILURE)
    {
        // this server do not have  the keyword and that keyword was not found in the Mysql database
        if (keyword_disk_lookup(file_key) == FAILURE && send2owner(file_key) == FAILURE)
        {
            ret = FAILURE;
        }
    }
    if (ret == FAILURE)
    {
        sprintf(rtn.msg, "Error %d:    The keyword '%s' not found:\n\
               1. Perhaps it is NOT correct, please verify you entered the keyword correctly.\n\
               2. Or it has been already deleted",
                         TRANS_NON_ERR, secure_key);
        shut_down(rtn.msg, TRANS_NON_ERR);
    }
    return ret;
} /* End keyword_find */


int send2owner(char *keyword)
{
    extern int gl_socket;
    char host[MACHINE_LEN];
    char address[ADDRESS_LEN];
    char port[12];
    char site[SITE_LEN];

    DBG();
    if (host_mapping_lookup(keyword, site, host, address, port) == SUCCESS)
    {
        int should_redirect = 1;
        replace_blank_character(site);
/*
 *  Intercom server, respect the current listening port
 */
#if defined (DMZ) || defined(INTERCOM)
        // use the same port
        DBG("port=%s gl_socket=%d", port, gl_socket);
        sprintf(port, "%d", gl_socket);
#else
        if (strcasecmp(host, server.address) == 0) // same host, check if port differs
        {
            should_redirect = 0;
            int port_number = 0;
            if (sscanf(port, "%d" , &port_number) == 1 && port_number != server.socket)
            {
                should_redirect = 1;
            }
        }
#endif
        if (should_redirect)
        {
            /* Tell client where to get the data from */
            sprintf(rtn.msg, "%s %s %s %s", site, host, address, port);
            shut_down(rtn.msg, WRONG_SERVER);
        }
    }
    return FAILURE;
} /* End send2owner */


void keyword_verify(char *keyword)
{
    char tmp_key[5];
    int cnt;
    int cnt1;

    DBG("keyword='%s'", keyword);

    for (cnt = 0; cnt < BAD_ARRAY_SIZE; ++cnt)
    {
        for (cnt1 = 0; cnt1 <4; ++cnt1)
            tmp_key[cnt1] = bad_key_array[cnt][cnt1]-1;

        if (strncmp(tmp_key, keyword, 4) == 0)
        {
            /* If reached this point, bad keyword found */
            for (cnt1 = 0; cnt1 < 4; ++cnt1)
                keyword[cnt1] += 1;
            return;
        } /* end if for bad keyword found */
    } /* end for */
} /* End function */


/* Look up history for keyword */
int history_lookup(char *key)
{
    FILE *fp;

    DBG();

    /* Build file name */
	/* If history file exists, tell user */
	strcpy3(bf.file_name, HISTORY_FILE_PATH, key, ".history");
    if ((fp = fopen(bf.file_name, "r")) != NULL)
	{
        int len = 1;
	    rtn.len = strcpy4(rtn.msg, "Data with keyword '", key, "' has been deleted.  ", "Transactions performed include:\n\n");

	    /* Scan past first line of text in history file */
	    /* Just put this line in a temporary buffer */
	    line_get(fp, bf.buffer);

        while ((rtn.len < 4000) && (len > 0))
        {
            len = line_get(fp, rtn.msg+rtn.len);
	        rtn.len += len;

	        /* Add the carriage return that was stripped off */
	        rtn.msg[rtn.len++] = '\n';
        } /* End while */

	    fclose(fp);
	    shut_down(rtn.msg, NON_ERR);
	} /* End if for history file present */
} /* end history_lookup */
