/****************************************************************************
 *
 * Function:	email_send
 *
 * Description:	Sends email to specified user.
 *
 ***************************************************************************/

#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdio.h>
#include <sys/uio.h>
#include <unistd.h>
#include <string.h>
#include <strings.h>
#include <stdlib.h>
#include <errno.h>

#include "server_params.h"
#include "global_server_errs.h"
#include "global_server_params.h"
#include "global_server_prototypes.h"
#include "strcpy.h"
#include "ldapfsl.h"
#include "global_debug.h"
#include "trans_server_defines.h"
#include "trans_server_globals.h"
#include "rtn.h"

/* Send a mail message using sendmail */
void email_send(char *replyto, char *recipients, char *subject, char *body)
{
    extern TRANS_FILE_STAT fs;
    char command[2048];
    char host_name[128];
    FILE *po;
    FILE *popen();
    char *fake_replyto = NULL;
    int  valid_recipient = 1;

    DBG("replyto='%s', recipients='%s', subject='%s' and body='%s'", replyto, recipients, subject, body);

    /* Sanity check to verify complete internet address passed in */
    if (strchr(recipients, '@') == NULL)
    {
        LDAP_RETURN_DATA * ldap_ret = ldapfsl_lookupByCoreId(recipients);
        if (GOOD_LDAP_RETURN_DATA(ldap_ret))
        {
            recipients = ldap_ret->info[0]->friendly_email;
        }
        else
        {
            valid_recipient = 0;
        }
        ldapfsl_free_return_data(ldap_ret);
    }
    else
    {
         if (ldapfsl_exists_account_by_email(recipients) == DBNO && ldapfsl_exists_account_by_coreid(recipients) == DBNO)
         {
             valid_recipient = 0;
         }
    }

    if (valid_recipient == 0)
    {
        rtn.len += sprintf(rtn.msg+rtn.len, "*** Warning !!! Could not find destination email for '%s' ***.\n", recipients);
        rtn.len += sprintf(rtn.msg+rtn.len, "*   To send multiple files/dirs at once, use :  trans -f <item1> <item2> ?\n");
        rtn.len += sprintf(rtn.msg+rtn.len, "*   To send a 'secure keyword' to other email for this transfer, use :  trans -m %s  <new.email> )\n", fs.key);
        rtn.len += sprintf(rtn.msg+rtn.len, "* (for more details about these parameters, check command help:  trans -H -<param>)\n\n");
        return;
    }

    if ((replyto[0] != '\0') && (strchr(replyto, '@') == NULL))
    {
        LDAP_RETURN_DATA * ldap_ret = ldapfsl_lookupByCoreId(replyto);
        if (GOOD_LDAP_RETURN_DATA(ldap_ret))
        {
            replyto = ldap_ret->info[0]->friendly_email;
        }
        ldapfsl_free_return_data(ldap_ret);
    }
    // REPLY-TO: and FROM:   MUST be "@nxp.com"
    if (replyto[0] && strcasestr(replyto, EMAIL_SUFFIX) == NULL)
    {
        fake_replyto = replyto;
        replyto =  admin.err_email;
    }
    if (replyto[0] == '\0')
    {
        replyto =  admin.err_email;
    }
    sprintf(command, "/usr/lib/sendmail -f %s -t", replyto);


    DBG("command=%s", command);
    DBG("replyto='%s', recipients='%s'", replyto, recipients);

#if defined(LDAP_BYPASS_AUTHENTICATION)
    DBG("not sending email, due to LDAP_BYPASS_AUTHENTICATION");
    return;
#endif

#if !defined(DO_NOT_SEND_EMAIL)
    po = popen(command, "w");
#else
    {
        static int counter = 0;
        const char email_test_file_name[64] ;
        sprintf(email_test_file_name, "transcend_email_test_%02d.txt", ++counter);
        po = fopen(email_test_file_name, "w");
        DBG("email being saved into file %s", email_test_file_name);
    }
#endif

    /* If could not open the pipe, cannot send e-mail */
    if (po == NULL)
    {
         DBG("popen(): /usr/lib/sendmail failed errno=%d message=%s", errno, strerror(errno));
         return;
    }

    fprintf(po, "To: %s\n", recipients);

    fprintf(po, "From:  %s\n", replyto);
    if (fake_replyto != NULL)
    {
        /* do not send CC for now, this used to the original FROM */
       // fprintf(po, "Cc:  %s\n", fake_replyto);
    }
    fprintf(po, "Reply-To:  %s\n", replyto);

    /* Write out the email subject */
    fprintf(po, "Subject:  %s\n", subject);

    /* Write out the email body */
    fprintf(po, "%s\n\n", body);

    /* Get the name of the current machine */
    gethostname(host_name, 64);

    /* This is present just to let user know where e-mail came from */
    fprintf(po, "-- Message generated by %s on %s\n", so.program, host_name);

#if !defined(DO_NOT_SEND_EMAIL)
    if (pclose(po) == -1)
    {
         DBG("pclose(): /usr/lib/sendmail failed errno=%d message=%s", errno, strerror(errno));
    }
#else
   fclose(po);
#endif
    return;
} /* End email_send */


/* Sends e-mail using a file already created */


void email_file_send(
    char *replyto,
    char *recipients,
    char *subject,
    char *file)
{
    int fd;
    int size;
    char buffer[5 * BUFFER_SIZE];

    /* Open file with message to send */
    if ((fd = open(file, O_RDONLY)) == EOF)
    {
        sprintf(buffer, "Unable to read output from file '%s'\n", file);
    }
    else
    {
        if ((size = read(fd, buffer, sizeof(buffer) -1)) > 0)
        {
            buffer [size] = 0;
            email_send(replyto, recipients, subject, buffer);
        }
        close(fd);
    }

} /* End email_file_send */




void email_msg_file_send(
        char *replyto,
        char *recipients,
        char *subject,
        char *msg,
        char *file)
{
    int fd;
    int size;
    char buffer[5 * BUFFER_SIZE];

    /* Open file with message to send */
    if ((fd = open(file, O_RDONLY)) == EOF)
    {
        sprintf(buffer, "Unable to read output from file '%s'\n", file);
    }
    else
    {
        int len_msg = strlen(msg);
        size_t size_rest = sizeof(buffer) -1 - len_msg;
        memcpy(buffer, msg, len_msg);
        if (size_rest < sizeof(buffer) && (size = read(fd, &buffer[len_msg], size_rest) > 0))
        {
            buffer [size] = 0;
            email_send(replyto, recipients, subject, buffer);
        }
        close(fd);
    }
}





/* Sends error message to user and system administrator */
/* Also exits current transaction */
void email_send_user(char *user_email, char *subject, char *body, int error)
{
    DBG("user_email='%s'", user_email);
    DBG("subject='%s'", subject);
    DBG("body='%s'", body);

    /* Send message to user first */
    email_send("", user_email, subject, body);

    /* Now send message to system administrator */
    email_send("", admin.err_email, subject, body);

    /* Now exit this transaction */
    shut_down(body, error);
} /* End email_send_user */
