#ifndef TRANSAPI
/****************************************************************************
 *
 * Functions:	icom_put, icom_get, icom_delete, icom_info, icom_size, etc.
 *
 * Description:	Interface functions which allows calling program
 *              to perform all defined user InterCom transactions.
 *    
 *    Returns:  All functions return 0 if successful.
 *              They return a negative number if unsuccessful.
 *
 * Inputs:	msg_ptr points to a message returned from the InterCom client.
 *          keyword is an 8 or 9 character string originally
 *          generated by the InterCom server.
 *          file_name is a file or directory to be transferred 
 *          to the InterCom repository.
 *
 ***************************************************************************/

#include <errno.h>
#include <malloc.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <alloca.h>
#include <strings.h>
#include <string.h>
#include <unistd.h>
#include <sys/uio.h>
#include <netinet/in.h>
#include <inttypes.h>
#include <openssl/ssl.h>

#include "client_files.h"
#include "client_lib.h"
#include "global_defines.h"
#include "client_defines.h"
#include "global_params.h"
#include "intercom_lib.h"
#include "trans_client_errs.h"
#include "trans_defines.h"
#include "trans_prototypes.h"
#include "rtn.h"
#include "strcpy.h"
#include "server_params.h"
#include "trans_defines.h"
#include "company.h"
#include "transapi_defines.h"
#include "transapi_prototypes.h"
#include "gzio.h"
#include <zlib.h>

#include "global_debug.h" // Mazieri's debug facilities

SSL *ssl = 0;
int log_cnt = 0;
TRANSACTION_PARAMS tr;
char certificate_dir[PATH_SIZE];
char certificate_file[FILE_SIZE];
TRANS_TOOL  tool;
int gl_is_web = 0;

static char   gl_read_buffer[BUFFER_SIZE];
static char * gl_msg_pointer = 0;
static char * gl_file_ptr    = 0 ;
static char * gl_file_type   = 0;

char * get_global_msg()
{
    DBG();
    return gl_msg_pointer;
}


char * get_global_file_ptr()
{
    return gl_file_ptr;
}


char * get_global_file_type()
{
    return gl_file_type;
}


char * get_read_buffer()
{
    return gl_read_buffer;
}

int specified_repository_set(int index)
{
    DBG();

    strcpy(server.address, repository[index].address);
    strcpy(server.machine, repository[index].machine);
    server.socket = htons(repository[index].socket);
    strcpy(server.site, repository[index].name);

    return(index);
} /* End default_repository_set */


extern char global_friendly_email[];
extern char global_keyword[];
extern TRANS_FILE_TYPE global_file_type;
extern long long global_final_size;

int email_convert(char *email, char *array[])
{
    int cnt;
    char *ptr;
    char string[256];
    char *string_ptr;
    int len = 0;
    int total_len;

    DBG();

    /* If no email specified, return 0 */
    if (strcmp(email, NONE) == 0)
        return(0);

    string_ptr = string;
    total_len = strcpy2(string, email, ",");

    strcpy2(string, email, ",");

    for (cnt = 0; cnt <6; ++cnt)
    {
	    ptr = strchr(string_ptr, ',');

	    if (ptr == NULL) break;

	    ptr[0] = '\0';
	    array[cnt] = malloc(strlen(string_ptr)+1);
	    len += strcpy1(array[cnt], string_ptr) + 1;

	    if (len >= total_len) break;
	
	    string_ptr = ptr+1;
    }

    return(cnt+1);
} /* End email_convert */


/* Initialize data InterCom client must send to the server */
/* this function must be called before other InterCom functions are called */
void defaults_init(char *ip_addr, char *core_id, char *friendly_email, char *name)
{
    extern int global_dlt;
    extern char remote_dir[];
    extern int compression ;

    DBG("ip_addr='%s', core_id='%s', friendly_email='%s', name='%s'", ip_addr, core_id, friendly_email, name);

    user_params_init();
    strcpy (user.machine_type, "TransGUI"); // it will be used in the server in transfer_type_set()
    strcpy (user.from_company, "External Transweb");
    strcpy(so.program, "TransWeb");
    compression = DBYES;

    /* Initialize email and name */
    strcpy(user.name, "Unknown Name");

    if ((core_id != NULL) && (core_id[0] != '\0'))
    {
	    str_lower(core_id);
	    strcpy(user.email, core_id);
	    strcpy(user.login, core_id);
    }
    else if (friendly_email != NULL && friendly_email[0] != '\0')
    {
        str_lower(friendly_email);
        strcpy(user.email, friendly_email);
        strcpy(user.login, friendly_email);
    }
    else {
        strcpy(user.email, NONE);
	    strcpy(user.login, NONE);
    }
    
    DBG("user.email='%s', user.login='%s'", user.email, user.login);
    strcpy(global_friendly_email, NONE);
    
    /* Indicate default for deleting file if exists is yes */
    /* This is done because the user is prompted if the file exists */
    global_dlt = DBYES;

    //strcpy(user.login, user.email);
    
    icom_repository_set(0);
    strcpy(remote_dir, NONE);
    
    /* Initialize user's machine, login, etc. */
    DBG("before gethostbyname, user.mach='%s'", user.mach);
    gethostname(user.mach, MACHINE_LEN);
    DBG("after gethostbyname, user.mach='%s'", user.mach);

    ip_find(user.addr, user.mach);
    DBG("after ip_find(), user.addr='%s' AND user.mach='%s'", user.addr, user.mach);
    
    strcpy(user.cwd, NONE);
    strcpy(user.machine_type, "Web_browser");
    strcpy(user.from_company, COMPANY_NAME);
} /* End defaults_init */


/* Perform  authentication*/
/* Returns SUCCESS if authentication successful */
/* Returns negative error code if unable to authenticate user */
/* msg_ptr holds message returned from InterCom server */
int icom_authen(char *user_id, char *pwd)
{
    DBG("user_id='%s', pwd='%s'", user_id, pwd);

    gl_msg_pointer = rtn.msg;

    /* Make sure this is an external customer if at external site */
    icom_repository_set(0);

#ifdef EXTERNAL_TRANSWEB
    if (strchr(user_id, '@') == NULL)
    {
	    strcpy(rtn.msg, external_auth_err);
	    return(EXTERNAL_AUTH_ERR);
    }
#endif

    return(dbx500authen(user_id, pwd));
} /* end icom_authen */


/* Retrieve defined company names from server */
/* If call to this function is successful, company names */
/* Company names returned with pointer passed to this function */
/* string format is company name;email address;TransNet access */
/* If company does not have default email address, email set to '0' */
/* TransNet acces set to 'yes' if a remote directory must be specified */
char **icom_company_rtv()
{
    char **company_list;
    DBG();

    gl_msg_pointer = rtn.msg;
    icom_repository_set(0);
    dblist_request(DBTRANSWEB_COMPANY_RTV, NONE, NONE, &company_list);

    return(company_list);
} /* end icom_company_rtv */


char **icom_repository_rtv()
{
    int cnt;
    char **repository_list = NULL;
    int rep_counter = 0;

    gl_msg_pointer = rtn.msg;
    icom_repository_set(0);
    rep_counter = dblist_request(DBTRANSWEB_REPOSITORY_RTV, NONE, NONE, &repository_list);

    DBG("rep_counter=%d pointer of repository_list=%p", rep_counter, repository_list);

    /* If valid list returned, replace hard coded values with list retrieved */
    if ((repository_list != NULL) && (repository_list[0] != NULL))
    {
	    for (cnt = 1; repository_list[cnt] != NULL; ++cnt)
	    {
            DBG("repository_list[cnt]=%s", repository_list[cnt]);
            sscanf(repository_list[cnt], "%[^;]%*c%*[^;]%*c%c%*c %c%*c %[^;]%*c %[^;]%*c %d",
	            repository[cnt-1].name, &repository[cnt-1].extension, &repository[cnt-1].secure_extension, 
	            repository[cnt-1].machine, repository[cnt-1].address, &repository[cnt-1].socket);
	    } /* end for */
    } /* End if */

    return(repository_list);
} /* end icom_repository_rtv */


/* This function puts a file in the InterCom repository */
/* When this function is called, the file name, company, and description have been parsed and are */
/* passed into the function */
/* remote_email holds one to six space separated email addresses */
/* If string is empty default email addresses used */
/* delete flag holds DBYES (1) for delete after first retrieval */
/* and DBNO (2) for no deletion after first retrieval */
int icom_put_init(char *file_name, char *company_line, char *description, char *remote_email, TRANS_FILE_TYPE file_type, int delete, int local_compress, unsigned long long size)
{
    int req_type;
    char *email_type;
    char *email_ptr;
    char tmp_sock[16];
    int ret;
    char remote_dir[64];
    char company_email[1024];
    extern int compression;



    /* Initialize server machine name, address, and socket */
    gl_msg_pointer = rtn.msg;

   // ret = sscanf(company_line, "%[^;]%*c%*[^;]%*c%[^;]%*c%[^;]%*c%[^;]%*c%*[^;]%*c%[^;]%*c%[^;]",
    ret = sscanf(company_line, "%[^;]%*c%[^;]%*c%[^;]%*c%[^;]%*c%[^;]%*c%[^;]%*c%[^;]%*c%[^;]",
                 server.site, server.machine, server.address, tmp_sock, company_email, remote_dir);
    DBG("fields=%d line=%s", ret, company_line);
    if (ret < 4)
    {
	    strcpy(rtn.msg, "Invalid format\n");
	    return(-1);
    }

    /* Convert socket number to integer */
    server.socket = htons(atoi(tmp_sock));

    /* build email addresses */
    if ((remote_email == NULL) || (remote_email[0] == '\0'))
    {
	    if (strcmp(company_email, NONE) != 0)
	        email_ptr = company_email;
	    else 
	        email_ptr = NULL;
    }
    else 
        email_ptr = remote_email;

    if (email_ptr == NULL) email_type = NONE;
    else email_type = "send_email";

    if (delete == DBYES)
        req_type = DBPUTDLT_DATA;
    else 
        req_type = DBPUT_DATA;

	 /* Connect to the database server */
    compression = local_compress;
    global_final_size = 0;
	
    ret = init_trans_socket(req_type, file_name,email_ptr, NONE, size, 16895, file_type, email_type, NONE, NONE, NONE, NONE, NONE);

    if (ret != SUCCESS)
    {
        gl_msg_pointer = rtn.msg;
	    return(ret);
    }

    /* Send file description */
    if (email_ptr != NULL)
    {
	    put_string(description);
	    put_string(email_ptr);
    }

    /* Retrieve the file keyword */
    get_string(rtn.msg);

    /* Scan keyword into global variable */
    sscanf(rtn.msg, "%*s %*s %*s %s", global_keyword);

    if ((ret = get_short()) < 0) 
    {
	    get_string(rtn.msg);
	    return(ret);
    }
    /* Prepare to write compressed data to socket */
    else return(0);
} /* End icom_put_init */




/* Prepare to read/write compressed data to the socket */
FILE * icom_put_compress_init(char *file_name, char *company_line, char *description, char *remote_email,  int remove)
{
    FILE *file = NULL;
    unsigned long long size = 0;
    TRANS_FILE_TYPE file_type =  'e';

    DBG("file_name='%s', company_line='%s', description='%s', remote_email='%s'", file_name, company_line, description, remote_email);
    gl_msg_pointer = rtn.msg;

    if(icom_put_init(file_name, company_line, description, remote_email, file_type, remove, DBYES, size) == 0)
    {
        file = icom_open("w", size, 1, 'e');
        if (file == NULL)
        {
            strcpy(rtn.msg, gz_sockopen_err);
        }
    }

    DBG("file=%p", file);
    return((FILE *)file);
} /* end icom_put_compress_init */


FILE * icom_get_compress_init(long long size)
{
    FILE *file;
    DBG();

    gl_msg_pointer = rtn.msg;
    file = icom_open("r", size, 1, 'e'); 

    if (file == NULL)
    {
	    strcpy(rtn.msg, gz_sockopen_err);
	    return(NULL);
    } else 
        return((FILE *)file);
} /* end icom_get_compress_init */


long long icom_put_send(int fd)
{
    long long size = 0;
    char buffer[BUFFER_SIZE];
    int len;

    DBG();

    /* Currently has no effect because enable, second argument set to 0 */
    trans_hash_init(size, 1, UNCOMPRESSED, "r", DBNO);

    while ((len = read(fd, buffer, BLOCK_SIZE)) > 0)
    {
	    put_binary_string(buffer,len);
	    size += (long long)len;
    }

    /* Close file no longer needed */
    close(fd);
    return(size);
} /* End icom_put_send */


/* close connection when sending compressed data */
int icom_put_compress_close(FILE *file, char *description)
{
    DBG();

    long long icom_close(FILE *file, char file_type);
    long long final_size = icom_close(file, 'e');

    return(icom_put_close(final_size, description, 'e'));
} /* end icom_put_compress_close */


/* close connection when retrieving compressed data */
int icom_get_compress_close(FILE *file)
{
    DBG();

    long long icom_close(FILE *file, char file_type);

    icom_close(file, 'e');

    return(icom_get_close());
} /* end icom_get_compress_close */


/* Close connection when sending uncompressed data */
int icom_put_close(long long size, char *description, char file_type)
{
    int ret;
    char mail_buffer[BUFFER_SIZE];

    DBG();

    /* Point to the return message */
    gl_msg_pointer = rtn.msg;

    /* Send end of file indication */
    if (put_short(0) != SUCCESS)
    {
	    sprintf(rtn.msg, bad_put, errno, HELP_MSG);
	    return(BAD_PUT);
    } /* End if */

    /* Send final size of file */
    put_longlong(size);

    /* If sending data to the SecNet, retrieve the mail buffer */
    if ((global_keyword[8] == 'p') || (global_keyword[8] == 'P'))
        get_string(mail_buffer);
    else
        mail_buffer[0] = '\0';

    /* Get the return code */
    /* Also get the string to put in the log */
    ret =get_log_string();

    /* For the FSS library used on the FSS IT web site */
    /* the client sends the email */
    /* For the Web browser, no email is currently sent */
    /* For external FSS customers, the server on the SecNet writes an email file */
    if ((ret == SUCCESS) && (mail_buffer[0] != '\0'))
        keyword_process_mail(mail_buffer, description, file_type, rtn.msg+strlen(rtn.msg));

    return(ret);
} /* End icom_put_close */


int icom_get_init(char *primary_key, char *secondary_key, int remove)
{
    DBG("remove=%d", remove);

    gl_msg_pointer = rtn.msg;

    if (remove == DBYES)
        return(get_big_file_init(DBGETDLT_SERIAL, DBGET_SERIAL, primary_key, secondary_key, rtn.msg, NONE, NONE));
    else 
        return(get_big_file_init(DBGET_SERIAL, DBGET_SERIAL, primary_key, secondary_key, rtn.msg, NONE, NONE));
} /* end icom_get_init */


/* Get return message from server and close socket */
int icom_get_close()
{
    
    DBG();

    /* Point to the return message */
    gl_msg_pointer = rtn.msg;

    /* Send final ack */
    if (put_short(0) != SUCCESS)
    {
	    sprintf(rtn.msg, bad_put, errno, HELP_MSG);
	    return(BAD_PUT);
    } /* End if */

    /* Get the return code */
    return(get_ret_code());
} /* End icom_get_close */


/* Transfer file or directory to InterCom repository */
/* Symbolic links are not included */
/* file _name holds file or directory to be transferred */
/* Absolute or relative paths may be specified with file name */
/* user_array is an array of pointers with the official user ID */
/* of users to receive email notification with a secure keyword */
/* The list is terminated with a NULL pointer */
/* If no email notification is being sent, first pointer points to NULL */
/* If email is being sent, description holds short description user */
/* wishes to be sent in the email message */
/* If no email is being sent or if there is no description, */
/* the NULL pointer i.e. "" can be passed in */
/* File type allows user to specify binary or ASCII data */
/* In most cases he can ignore the file type, and it is set to UNSPECIFIED */
/* file type is a new feature for 3.0 of InterCom */
/* msg_ptr points to message returned from InterCom server */
/* Returns 0 if transaction successful */
/* Returns negative number if transaction fails */
int icom_put(char *file_name, char *user_array[], char *description, TRANS_FILE_TYPE file_type, char **keyword_ptr)
{
    int cnt;
    char *ptr[9];

    DBG();

    ptr[0] = NULL;
    gl_msg_pointer = rtn.msg;

    ptr[1] = "-p";
    ptr[2] = file_name;

    *keyword_ptr = global_keyword;

    return(dbput_big_file(DBPUT_DATA, file_type, description, cnt+3, &rtn.msg));
} /* End icom_put */


/* Perform put transaction on a directory */
/* Symbolic links are included */
int icom_put_links(char *file_name, char *user_array[], char *description, TRANS_FILE_TYPE file_type, char **keyword_ptr)
{
    DBG();

    int cnt;
    char *ptr[9];

    ptr[0] = NULL;
    ptr[1] = "-t";
    ptr[2] = file_name;
    for (cnt = 0; cnt <6; ++cnt)
    {
	    if (user_array[cnt] == NULL) break;
	        ptr[cnt+3] = user_array[cnt];
    }

    gl_msg_pointer = rtn.msg;
    *keyword_ptr = global_keyword;

    return(dbput_big_file(DBPUT_DATA, file_type, description, cnt+3, &rtn.msg));
} /* End icom_put_links */


/* Perform put transaction and specify deletion after first retrieval */
int icom_put_delete(char *file_name, char *user_array[], char *description, TRANS_FILE_TYPE file_type, char **keyword_ptr)
{
    int cnt;
    char *ptr[9];

    DBG();

    ptr[0] = NULL;
    ptr[1] = "-P";
    ptr[2] = file_name;

    for (cnt = 0; cnt <6; ++cnt)
    {
	    if (user_array[cnt] == NULL) break;
	    ptr[cnt+3] = user_array[cnt];
    }

    gl_msg_pointer= rtn.msg;
    *keyword_ptr = global_keyword;

    return(dbput_big_file(DBPUTDLT_DATA, file_type, description, cnt+3, &rtn.msg));
} /* End icom_put_delete */


/* Perform put transaction on a directory */
/* Symbolic links are included */
/* and the data is deleted after the first retrieval */
int icom_put_delete_links(char *file_name, char *user_array[], char *description, TRANS_FILE_TYPE file_type, char **keyword_ptr)
{
    int cnt;
    char *ptr[9];

    DBG();

    ptr[0] = NULL;
    ptr[1] = "-T";
    ptr[2] = file_name;

    for (cnt = 0; cnt <6; ++cnt)
    {
	    if (user_array[cnt] == NULL) break;
	    ptr[cnt+3] = user_array[cnt];
    }

    gl_msg_pointer = rtn.msg;
    *keyword_ptr = global_keyword;

    return(dbput_big_file(DBPUT_DATA, file_type, description, cnt+3, &rtn.msg));
} /* End icom_put_delete_links */


/* Retrieve a file or directory from the InterCom repository */
/* Path points to path where file will be placed */
/* Absolute or relative paths can be used */
/* Pass in "." if want to use current working directory */
/* file_name points to name of file retrieved */
/* Memory is allocated by icom_get */
/* Calling function is responsible for freeing this memory */
/* msg_ptr points to message returned from InterCom server */
/* Returns 0 if transaction is successful */
/* Returns negative number if transaction fails */
int icom_get(char *primary_key, char *secondary_key, char *user_path, TRANS_FILE_TYPE file_type)
{
    DBG();

    gl_msg_pointer= rtn.msg;
    gl_file_ptr = global_keyword;

    gl_file_type = &global_file_type;

    return(get_big_file(DBGET_SERIAL, DBGET_SERIAL, primary_key, secondary_key, user_path, NONE));
} /* End icom_get */


/* Retrieve a file or directory from InterCom repository */
/* and delete data from repository after is is successfully retrieved */
/* msg_ptr points to message returned from InterCom server */
/* Returns 0 if transaction is successful */
/* Returns negative number if transaction fails */
int icom_get_delete(char *primary_key, char *secondary_key, char *user_path, TRANS_FILE_TYPE file_type)
{
    DBG();

    gl_msg_pointer= rtn.msg;
    gl_file_ptr = global_keyword;
    gl_file_type = &global_file_type;

    return(get_big_file(DBGETDLT_SERIAL, DBGETDLT_SERIAL,primary_key, secondary_key, user_path, NONE));
} /* End icom_get_delete */


/* Functions to return information about data in the InterCom repository */
/* Retrieve information about specified file/directory */
/* present in InterCom repository using file keyword */
/* msg_ptr points to message returned from InterCom server */
/* Returns 0 if transaction successful */
/* Returns negative number if transaction fails */
int icom_info(char *primary_key, char *secondary_key)
{
    DBG();
    gl_msg_pointer = rtn.msg;
    return(dbsend_transweb_keyword_request(DBINFO_DATA, primary_key, secondary_key));
} /* End icom_info */


int icom_mode(char *primary_key, char *secondary_key)
{
    DBG();
    gl_msg_pointer = rtn.msg;
    return(dbsend_transweb_keyword_request(DBMODE_DATA, primary_key, secondary_key));
} /* End icom_info */


/* Retrieve history of transactions on specified data */
int icom_history(char *primary_key, char *secondary_key)
{
    DBG();

    gl_msg_pointer = rtn.msg;
    return(dbsend_transweb_keyword_request(TRANSWEB_HISTORY, primary_key, secondary_key));
} /* End icom_history */


/* Retrieve original and compressed size of data specified with keyword */
 int icom_size(char *primary_key, char *secondary_key)
{
    DBG();

    gl_msg_pointer = rtn.msg;
    return(dbsend_transweb_keyword_request(DBSIZE_CHECK, primary_key, secondary_key));
} /* End icom_size */


/* Functions that modify data already present in the repository */
/* Delete specified data from InterCom repository */
/* Pass in keyword of data to delete */
int icom_delete(char *primary_key, char *secondary_key)
{
    DBG();
    gl_msg_pointer = rtn.msg;
    return(dbsend_transweb_keyword_request(DBDLT_DATA, primary_key, secondary_key));
} /* end icom_delete */


/* Extend the expiration date on data 1-3 additional working days */
int icom_extend(char *primary_key, char *secondary_key, int days)
{
    DBG();

    gl_msg_pointer = rtn.msg;
    return(extend_transweb_file(primary_key, secondary_key, days));
} /* end icom_extend */


/* Send email to 1-6 users for data with specified keyword */
/* user_email holds multiple comma separated email addresses */
int icom_mail_keyword(char *primary_key, char *secondary_key, char *user_email, char *description)
{
    DBG();

    int ret;

    gl_msg_pointer= rtn.msg;
    if ((ret = is_transweb_keyword(DBSEND_KEYWORD, primary_key, secondary_key)) < 0) 
        return(ret);
    
    repository_find(primary_key[8]);
    
    /* Connect to the TransWeb database */
    if ((ret = init_trans_socket(DBSEND_KEYWORD, primary_key, NONE, NONE, 0,  0, UNSPECIFIED, secondary_key, NONE, NONE, NONE, NONE, NONE)) != SUCCESS)
        return(ret);

	put_string(description);
    put_string(user_email);
    
    return(get_ret_code());
} /* End icom_mail_keyword */


int icom_company_add(char *primary_key, char *secondary_key, char *company)
{
    int ret;

    DBG();

    gl_msg_pointer = rtn.msg;
    if ((ret = is_transweb_keyword(DBSEND_KEYWORD, primary_key, secondary_key)) < 0) return(ret);

    repository_find(primary_key[8]);

    /* Connect to the TransWeb database */
    if ((ret = init_trans_socket(DBCOMPANY_ADD, primary_key, NONE, NONE, 0,  0, UNSPECIFIED, secondary_key, NONE, NONE, NONE, NONE, NONE)) != SUCCESS)
        return(ret);

	put_string(company);

    return(get_ret_code());
} /* End icom_company_add */


/* Turn on email notification for specified data */
/* Whenever a user retrieves specified data, */
/* the sending user is sent email notification */
int icom_set_file_email(char *primary_key, char *secondary_key)
{
    DBG();    
    gl_msg_pointer = rtn.msg;
    return(dbsend_transweb_keyword_request(DBSET_FILE_EMAIL, primary_key, secondary_key));
} /* End icom_set_file_email */


/* Cancel previously set file email notification */
int icom_can_file_email(char *primary_key, char *secondary_key)
{
    DBG();    
    gl_msg_pointer = rtn.msg;
    return(dbsend_transweb_keyword_request(DBCAN_FILE_EMAIL, primary_key, secondary_key));
} /* End icom_can_file_email */


/* Lock specified data for retrieval */
/* This allows a user to prevent other users from retrieving */
/* data without deleting the data.  This transaction is */
/* useful when a user has given out a keyword and then wants */
/* to prevent the user from retrieving the data until he has */
/* verified the data is what the receiving user really needs */
int icom_lock(char *primary_key, char *secondary_key)
{
    DBG();

    gl_msg_pointer = rtn.msg;
    return(dbsend_transweb_keyword_request(DBLOCK_DATA, primary_key, secondary_key));
} /* End icom_lock */


/* Unlock data previously locked for retrieval with the */
/* icom_lock function */
int icom_unlock(char *primary_key, char *secondary_key)
{
    DBG();

    gl_msg_pointer = rtn.msg;
    return(dbsend_transweb_keyword_request(DBUNLOCK_DATA, primary_key, secondary_key));
} /* End icom_unlock */


/* Lock data for deletion, can be done only by owner */
int icom_delete_lock(char *primary_key, char *secondary_key)
{
    DBG();
    
    gl_msg_pointer = rtn.msg;
    return(dbsend_transweb_keyword_request(DBOWNER_DLT, primary_key, secondary_key));
} /* End icom_lock */


/* Unlock data previously locked for deletion with the */
/* icom_delete_lock function */
int icom_delete_unlock(char *primary_key, char *secondary_key)
{
    DBG();
    
    gl_msg_pointer = rtn.msg;
    return(dbsend_transweb_keyword_request(DBUSER_DLT, primary_key, secondary_key));
} /* End icom_delete_unlock */


/* Set email notification on for all files user owns */
/* Whenever a file the user owns is retrieved, the user receives email */
int icom_set_user_email()
{
    int cnt;
    int ret;
    DBG();
    
    gl_msg_pointer = rtn.msg;
    for (cnt = 0; cnt <6; ++cnt)
    {
	    /* Set up the repository to set email at */
	    specified_repository_set(cnt);
	    ret = dbsend_request(DBSET_USER_EMAIL, "all");
    } /* end for */

    return(ret);
} /* End icom_set_user_email */


/* Cancel previously set email notification */
int icom_can_user_email()
{
    int cnt;
    int ret;

    DBG();
    
    gl_msg_pointer = rtn.msg;
    for (cnt = 0; cnt <6; ++cnt)
    {
	    /* Set up the repository to set email at */
	    specified_repository_set(cnt);
	    ret = dbsend_request(DBCAN_USER_EMAIL, "all");
    } /* end for */

    return(ret);
} /* End icom_can_user_email */


/* Retrieve information about InterCom releases available for retrieval */
/* Returns message in command line format */
/* This will need to be changed for the Java release */
int icom_release_info()
{
    DBG();    
    gl_msg_pointer = rtn.msg;
    return(dbsend_request(DBGET_RELEASE_INFO, "releases"));
} /* End icom_release_info */


/* Retrieve specified InterCom release */
/* Returns message describing how to retrieve release using command line */
/* format if specified release is not present */
/* This will need to be changed for the Java release */
int icom_get_release(char *release)
{
    DBG();

    gl_msg_pointer = rtn.msg;
    strcpy(rtn.msg, "Not implemented\n");

    return(0);
    /* return(dbget_release(release, "trans")); */
} /* End icom_get_release */


/* Set data type for specified data to ASCII */
/* Useful when transferring data between unix, NT and Mac machines */
 int icom_set_ascii(char *primary_key, char *secondary_key)
{
    DBG();    
    gl_msg_pointer = rtn.msg;
    return(dbsend_transweb_keyword_request(DBSET_ASCII, primary_key, secondary_key));
} /* End icom_set_ascii */


/* Set data type for specified data to binary */
/* Useful when transferring data between unix, NT, and Mac platforms */
int icom_set_binary(char *primary_key, char *secondary_key)
{
    DBG();    
    gl_msg_pointer = rtn.msg;
    return(dbsend_transweb_keyword_request(DBSET_BINARY, primary_key, secondary_key));
} /* End icom_set_binary */


/* Retrieve information about specified user */
/* Information from the whois command along with information */
/* from the InterCom registry is returned */
/* Any string that identifies the user can be passed in */
/* If white space is present in the string, it is replaced with a '.' */
int icom_query(char *string)
{
    DBG();

    /* Replace all white space with a '.' */
    strexc(string, ' ', 46);
    strexc(string, '\t', 46);
    strexc(string, '\n', 46);
    gl_msg_pointer = rtn.msg;
    return(dbquery_user(DBQUERY_USER, string)); 
} /* End icom_query */


/* Verify user is registered in the InterCom registry */
/* Returns SUCCESS if registered */
/* Returns LOCK_ERR, () if user's account is locked */
/* Returns REG_ERR (-520) if user not registered */
/* Returns negative number for other error conditions */
/* msg_ptr holds message returned from InterCom server */
int icom_reg_check()
{
    DBG();

    gl_msg_pointer = rtn.msg;
    return(dbsite_check("b"));
} /* End icom_reg_check */


/* Set repository equal to index passed in */
void icom_repository_set(int index)
{
    DBG("index='%d'", index);

    extern TRANS_REPOSITORY repository[];

    DBG("server.address='%s'", repository[index].address);
    DBG("server.machine='%s'", repository[index].machine);
    DBG("server.site='%s'", repository[index].name);
    DBG("server.socket='%d'", repository[index].socket);

	strcpy(server.address, repository[index].address);
	strcpy(server.machine, repository[index].machine);
	strcpy(server.site, repository[index].name);
	server.socket = htons(repository[index].socket);

} /* End icom_repository_set */


void icom_repository_scan(char *line)
{
    DBG("line='%s'", line);

    char site_extension[8];

    /* Scan line into parameters */
    sscanf(line, "%[^;]%*c%[^;]%*c%[^;]%*c %[^;]%*c %d",
    server.site, site_extension, server.machine, server.address, &server.socket);
    server.socket = htons(server.socket);
} /* End icom_repository_scan */


/* Return file status */
/* Lock status, number of days file extended, etc. returned */
/* status is returned in a dynamic array */
/* byte 0 is */
char **icom_status(char *primary_key, char *secondary_key)
{
    char **ptr;
    DBG();

    gl_msg_pointer = rtn.msg;
    if (is_transweb_keyword(DBSTATUS_DATA, primary_key, secondary_key) != SUCCESS) return(NULL);

    repository_find(primary_key[8]);
    
    dblist_request(DBSTATUS_DATA, primary_key, secondary_key, &ptr);
    
    return(ptr);
} /* End icom_status */


/* Retrieve list of file keywords for data user has put in the repository */
char **icom_keys_rtv(int req_type, char *site)
{
    int ret;
    char **ptr = NULL;
    char **local_ptr;
    int cnt;
    int total_num = 0;
    int old_total, local_cnt, final_cnt;

    DBG("req_type='%d', site='%s'", req_type, site);

    /* Do the following for a specific site */
    if (strncasecmp(site, "All", 3) != 0)
    {
	    icom_repository_scan(site);
	    total_num = dblist_request(req_type, NONE, NONE, &ptr);
    } else {
	    /* Grab the latest copy of repository table */
	    /* Do the following for all of the sites */
	    for (cnt = 0; repository[cnt].name[0] != '\0'; ++cnt)
	    {
	        icom_repository_set(cnt);

	        /* Keep track of old number */
	        old_total = total_num;

	        /* Grab results from the list */
	        ret  = dblist_request(req_type, NONE, NONE, &local_ptr);

            if (ret < 0) continue;
            total_num += ret;

	        /* copy elemnts of list from local pointer to final pointer */
	        /* If nothing retrieved skip to next element */
	        if (old_total == total_num) continue;

	        ptr = realloc(ptr, sizeof (char *)*(total_num+1));
	        for (local_cnt = 0, final_cnt = old_total; local_ptr[local_cnt] != NULL; ++local_cnt, ++final_cnt)
	        {
		        ptr[final_cnt] = local_ptr[local_cnt];
	        } /* End for for doing copy */
	    } /* End for for each site */

        if (total_num <= 0)  ptr = NULL;
        else 
        {
	        ptr[total_num] = NULL;
	        strcpy(rtn.msg, "List of keywords retrieved.");
        } /* End else */
    
        /* If no keys returned, point first element to the empty string */
    } /* End else */
    
    if (ptr == NULL)
    {
	    ptr = malloc(sizeof(char *));
	    ptr[0] = NULL;
    }

    return(ptr);
} /* End icom_keys_rtv */


/* Retrieve list of secure keywords for current user */
char **icom_secure_keys_rtv(char *site)
{
    DBG();

    gl_msg_pointer = rtn.msg;
    /* This function does not get the status also */
    return(icom_keys_rtv(DBSECURE_KEYS, site));
} /* End icom_secure_keys_rtv */


char **icom_user_keys_rtv(char *site)
{
    DBG();

    char *status;
    gl_msg_pointer = rtn.msg;
    
    /* this function also returns the status */
    return(trans_keys_rtv(DBUSR_KEYS, site, &status));
} /* End icom_secure_keys_rtv */


/* Read compressed data from the socket */
/* The data is uncompressed as it is read */
/* file is the pointer returned from icom_get_compress_init */
/* buffer is the character array where data is placed */
/* len is the size of the buffer */
int icom_read (FILE *file_ptr, char *perl_buffer)
{
    char *my_buffer = perl_buffer != NULL ? perl_buffer : gl_read_buffer;
    int ret = tfile_gzread(file_ptr, my_buffer, BLOCK_SIZE);
    static long long int saved = -1;  // debug puprposes
#if defined(DEBUG)
    static int fd_saved = -1;
    if (ret > 0)
    {
        if (saved == -1)
        {
            fd_saved = open("/tmp/icom_read.saved.bin", O_CREAT | O_WRONLY, 0666);
            saved = 0;
        }
        if (fd_saved > 0)
        {
            saved += write(fd_saved, my_buffer, ret);
            DBG("total saved in /tmp/icom_read.saved.bin %lld bytes", saved);
        }
    }
    else
    {
        if (fd_saved > 0)
        {
            close(fd_saved);
        }
        fd_saved = -1;
        saved    = -1;
    }
#endif
    DBG("ret=%d", ret);
    return(ret);
} /* end icom_read */


/* Write data to the socket */
/* Data is compressed as it is written to the socket */
/* file is the pointer returned from icom_put_compress_init */
/* buffer holds the data to be written to the socket */
/* len is the length of the data */
long long icom_write(FILE *file_ptr, char *buffer, unsigned len)
{
    DBG();
    long long ret =  tfile_gzwrite((FILE *)file_ptr, buffer, len);
    global_final_size += ret;
    return(ret);
} /* End icom_write */


/* Delete all user keys present in the repository */
int icom_user_keys_delete(char *site)
{
    DBG();
    gl_msg_pointer = rtn.msg;
    return(trans_keys_delete(USER_KEYS_DELETE, site));
} /* End icom_delete_user_keys */


/* Delete all secure keys present in the repository */
int icom_secure_keys_delete(char *site)
{
    DBG();
    gl_msg_pointer = rtn.msg;
    return(trans_keys_delete(SECURE_KEYS_DELETE, site));
} /* End icom_delete_secure_keys */


/* Generate report using criteria specified by the user */
/* Fields are passed in as a comma separated list of the field numbers */
/* filters contain field number, = or !, and field value */
/* List of filters are separated by commas */
/* Dates have the form mm/dd/yy */
/* file_name holds name for local file */
int icom_summary_report(char *company_line, char *fields, char *time1, char *time2, char *filter_string, char *file_name)
{
    DBG();
    gl_msg_pointer = rtn.msg;
    return(icom_report_gen(DBREPORT_SUMMARY, company_line, fields, time1, time2, filter_string, file_name));
} /* End icom_summary_report */


int icom_usage_report(char *fields, char *company_line,  char *time1, char *time2, char *filter_string, char *file_name)
{
    DBG();
    gl_msg_pointer = rtn.msg;
    return(icom_report_gen(DBREPORT_USAGE, company_line, fields, time1, time2, filter_string, file_name));
} /* End icom_usage_report */


/* req_type holds the request type, summary( 69) or usage (51) */
/* report_fields holds a comma separated list of fields to put in the report */
/* start_time holds the begin time in the form mm/dd/yy */
/* end_time holds the end time in the form mm/dd/yy */
int icom_report_gen(int req_type,  char *company_line, char *report_fields, char *start_time, char *end_time, char *filter_string, char *file_name)
{
    DBG();

    char company_email[64];
    char tmp_sock[32];
    int ret;

    if (sscanf(company_line, "%[^;]%*c%*[^;]%*c%[^;]%*c%[^;]%*c%[^;]%*c%*[^;]%*c%[^;]%*c%[^;]", server.site, server.machine, server.address, tmp_sock, company_email, remote_dir) != 6)
    {
	    strcpy(rtn.msg, "Invalid format\n");
	    return(-1);
    }

    /* Convert socket number to integer */
    server.socket = htons(atoi(tmp_sock));

    /* Connect to InterCom server */
    if ((ret = init_trans_socket(req_type, report_fields, NONE, NONE, 0, 0, UNKNOWN, start_time, end_time, NONE, NONE, NONE, NONE)) != 0) 
        return(ret);

    /* Send the filter string */
    put_string(filter_string);

    /* Retrieve the file */
    if ((ret = full_file_get(file_name)) == 0)
        ret = get_ret_code();

    return(ret);
} /* End icom_report_gen */


/* Currently not being used */
/* Set authorization for multiple companies */
int icom_multiple_companies_set(char *primary_key, char *secondary_key, char *user_email, char *description)
{
    DBG();

    int ret;

    gl_msg_pointer = rtn.msg;

    if ((ret = is_transweb_keyword(DBSEND_KEYWORD, primary_key, secondary_key)) < 0) return(ret);

    repository_find(primary_key[8]);
    /* Connect to the TransWeb database */
    if ((ret = init_trans_socket(DBSEND_KEYWORD, primary_key, NONE, NONE, 0,  0, UNSPECIFIED, secondary_key, NONE, NONE, NONE, NONE, NONE)) != SUCCESS)
        return(ret);

	put_string(description);
    put_string(user_email);

    return(get_ret_code());
} /* End icom_multiple_companies_set */


FILE *icom_open(char *mode, long long hash_size, int hash_enable, TRANS_FILE_TYPE file_type) 
{
    DBG();

    FILE *file = tfile_gzopen(mode);
    trans_hash_init (hash_size, hash_enable, file_type, mode, DBNO);

    return(file);
} /* End icom_open */


long long icom_close (FILE *file, char file_type) 
{
    DBG();

    tfile_gzclose(file);

     /* Return the final size */
    return(global_final_size);
} /* End icom_close */


/* Use this function so the global file size will be updated */
long long icom_put_string(char *string, short len)
{
    DBG();

    global_final_size += put_binary_string(string, len);
    return(global_final_size);
} /* End icom_put_string */


/* Read data from the socket and write to standard out which causes it to download */
int icom_data_get(char *file_name, int retrieve_compressed, int remotely_compressed, long long size)
{
    DBG();

    int ret;
    FILE *file;

    if ((retrieve_compressed == DBYES) && (remotely_compressed == DBYES))
    {
        file = icom_get_compress_init(size);
        if (file == 0) return(-1);
    
        /* Now read in the data */
        while((ret = icom_read(file, gl_read_buffer)) > 0)
        {
            if (fwrite(gl_read_buffer, 1, ret, stdout)!= ret)
		    {
		        char *err_ptr = strerror(errno);
		        char err_string[8];

		        sprintf(err_string, "%d", errno);
		        rtn.len = strcpy5(rtn.msg, bad_write, RET2TAB, "'", file_name, "'.");
		    
		        strcpy7(rtn.msg+rtn.len,DOUBLE_RET, "Error message:  ", err_ptr, "\nError No:      ", err_string, DOUBLE_RET, HELP_MSG);
		    
		        put_short(BAD_WRITE);
		        close(sock);
		        return(BAD_WRITE);
		    }
        } /* End while */

        /* Now close connection */
        ret = icom_get_compress_close(file);
    /* For uncompressed data */
    } else {
        while ((ret = get_string(gl_read_buffer)) > 0)
        {
            if (fwrite(gl_read_buffer, 1, ret, stdout)!= ret)
		    {
		        char *err_ptr = strerror(errno);
		        char err_string[8];
		    
		        sprintf(err_string, "%d", errno);
		        rtn.len = strcpy5(rtn.msg, bad_write, RET2TAB, "'", file_name, "'.");
		    
		        strcpy7(rtn.msg+rtn.len,DOUBLE_RET, "Error message:  ", err_ptr, "\nError No:      ", err_string, DOUBLE_RET, HELP_MSG);
		    
		        put_short(BAD_WRITE);
		        close(sock);
		    
		        return(BAD_WRITE);
	        } /* End if for write failed */
        } /* End while */
	
        ret = icom_get_close();
    } /* End else */

    return(ret);
} /* End icom_data_get */


/* Get uncompressed file */
int icom_get_uncompressed()
{
    DBG();

    int ret;
    char buffer[BLOCK_SIZE];

    while((ret = get_string(buffer)) > 0)
    {
	    buffer[ret] = '\0';
	    printf(buffer);
    } /* end while */

    /* close the connection */
    return(icom_get_close());
} /* End icom_get_uncompressed */




/* Sends header to the server */
/* copied from client/transapi.c */
int trans_header_send(char *buffer)
{
    DBG("buffer\n%s", buffer);

    /* Send the header to the server */
    int ret;

    if ((ret = put_binary_string(buffer, (strlen(buffer+12)+12))) != SUCCESS)
    {
            close(sock);

            DBG("Unable to put_ssl_binary_string() string %d", ret);

            return(ret);
    } /* End if for unable to put string */

    /* Get the response from the server */
    ret = get_short();
        DBG("get_ssl_short() response %d", ret);

    /* Perform registration */
    if (ret == DBEMAIL)
        return(user_autoreg());

    if (ret >= SUCCESS) return(ret);

    /* If ret out of range, error getting data from the data base */
    if (ret == BAD_GET) {
        DBG("error getting data from the database since ret == BAD_GET (ret='%d')", ret);
        return(ret);
    }

    rtn.len += get_string(rtn.msg + rtn.len);
        close(sock);

    return(ret);
} /* end trans_header_send */


char *icom_c_array_2_perl_csv_string(char **c_array)
{
    static char string [1024];
    string[0] = 0;
    char *str = string;
    int   offset = 0;
    while (c_array != NULL && *c_array != NULL && strlen(*c_array) < (sizeof(string) - offset - 1))
    {
        if (str != string)
        {
            *str = ';' ;
            str++;
        }
        str += sprintf(str, "%s", *c_array);
        offset = str - string;
        c_array++;
    }
    return string;
}


#if defined(EXTERNAL_TRANSWEB)


short get_short(void)
{
    return get_ssl_short();
}


long get_long(void)
{
    return get_ssl_long();
}


short get_string(char *buffer)
{
    if (buffer == NULL)
    {
         return get_ssl_string(gl_read_buffer);
    }
    return get_ssl_string(buffer);
}


short put_short(short data)
{
    return put_ssl_short(data);
}


short put_long(unsigned long data)
{
    return put_ssl_long(data);
}


short put_string(char *string)
{
    return put_ssl_string(string);
}


short put_binary_string(char *string, short len)
{
    return put_ssl_binary_string(string, len);
}


short put_longlong(unsigned long long data)
{
    return put_ssl_longlong(data);
}

short init_socket(char *buffer)
{
    return ssl_init(buffer);
}

#endif // EXTERNAL_TRANSWEB


#endif /* For not TRANSAPI */
